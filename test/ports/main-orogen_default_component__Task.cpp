#include <rtt/os/main.h>

#include <iostream>
#include <rtt/internal/GlobalEngine.hpp>
#include <rtt/TaskContext.hpp>

#include <rtt/types/TypekitPlugin.hpp>
    
#include <rtt/transports/corba/ApplicationServer.hpp>
#include <rtt/transports/corba/TaskContextServer.hpp>
//#include <rtt/transports/corba/CorbaDispatcher.hpp>
#include <signal.h>


#include <rtt/Activity.hpp>

#include <rtt/base/ActivityInterface.hpp>

#include <string.h>

/* This has been converted from an actual orogen component to this
 * rather less complete thing. This file is based on autogenerated code
 * from the .orogen directory, and thus looks a bit messy.
 *
 * The goal here is to get close to an actual orogen component while not
 * pulling in too many external components, while still showing issues during
 * compiling and linking with orogen components.
 */

namespace orogen
{
    extern RTT::TaskContext* create_component__Task(std::string const& instance_name);
}

class Deinitializer
{
    friend Deinitializer& operator << (Deinitializer&, RTT::base::ActivityInterface&);

    std::vector<RTT::base::ActivityInterface*> m_activities;


public:
    ~Deinitializer()
    {
        for (std::vector<RTT::base::ActivityInterface*>::const_iterator it = m_activities.begin();
                it != m_activities.end(); ++it)
        {
            (*it)->stop();
        }

    }
};

Deinitializer& operator << (Deinitializer& deinit, RTT::base::ActivityInterface& activity)
{
    deinit.m_activities.push_back(&activity);
    return deinit;
}

void wait_for_termination(){
    usleep(10000000);
    return;
}

void *oro_thread(void *p){
    usleep(10000000);
    return NULL;
}

int ORO_main(int argc, char* argv[])
{
    std::cerr << "This is a compile only test. A runnable component cannot be provided in this scope.\n"
        << "Abort this program at any time you like." << std::endl;

    if (!RTT::corba::ApplicationServer::InitOrb(argc, argv)) {
        std::cerr << "Failed to initialize the ORB" << std::endl;
        return 1;
    }

    std::string prefix = "";

    bool use_naming = false;

    std::string task_name;

    std::map<std::string, std::string> rename_map;


// Initialize some global threads so that we can properly setup their threading
// parameters
RTT::internal::GlobalEngine::Instance(ORO_SCHED_OTHER, RTT::os::LowestPriority);


//First Create all Tasks to be able to set some (slave-) activities later on in the second loop
    task_name = "orogen_default_component__Task";
    if (rename_map.count(task_name))
        task_name = rename_map[task_name];
    else
        task_name = prefix + task_name;

    std::unique_ptr<RTT::TaskContext> task_orogen_default_component__Task(
            orogen::create_component__Task(task_name));

    
    RTT::corba::TaskContextServer::Create( task_orogen_default_component__Task.get(), use_naming );
    
//Create all Activities afterwards to be sure all tasks are created. The Activitied are also handeld by the deployment because
//the order needs to be known since slav activities are useable
//
    RTT::Activity* activity_orogen_default_component__Task = new RTT::Activity(
    ORO_SCHED_OTHER,
    RTT::os::LowestPriority,
    0,
    task_orogen_default_component__Task->engine(),
    "orogen_default_component__Task");

    
    { RTT::os::Thread* thread = dynamic_cast<RTT::os::Thread*>(activity_orogen_default_component__Task);
        if (thread)
            thread->setStopTimeout(10);
    }
    
    task_orogen_default_component__Task->setActivity(activity_orogen_default_component__Task);

   Deinitializer deinit;


    // Start some activities
    deinit << *activity_orogen_default_component__Task;

    RTT::corba::TaskContextServer::ThreadOrb(ORO_SCHED_OTHER, RTT::os::LowestPriority, 0);
    

    wait_for_termination();

    RTT::corba::TaskContextServer::ShutdownOrb(true);
    RTT::corba::TaskContextServer::DestroyOrb();


    return 0;
}

